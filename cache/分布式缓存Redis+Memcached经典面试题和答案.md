# 分布式缓存Redis+Memcached经典面试题和答案
### 1. Redis相比memcached有哪些优势？
1. memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型

2. redis的速度比memcached快很多

3. redis可以持久化其数据

### 2.Redis支持哪几种数据类型？
````
String、List、Set、Sorted Set、hashes
````

### 3.Redis集群方案应该怎么做？都有哪些方案？

1.twemproxy，大概概念是，它类似于一个代理方式，使用方法和普通redis无任何区别，
设置好它下属的多个redis实例后，使用时在本需要连接redis的地方改为连接twemproxy，
它会以一个代理的身份接收请求并使用一致性hash算法，将请求转接到具体redis，将结果再返回twemproxy。
使用方式简便(相对redis只需修改连接端口)，对旧项目扩展的首选。
问题：twemproxy自身单端口实例的压力，使用一致性hash后，对redis节点数量改变时候的计算值的改变，
数据无法自动移动到新的节点。

### 4.Redis回收使用的是什么算法？
````
LRU算法
````

### 5.为什么要做Redis分区？

分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。
如果没有分区，你最多只能使用一台机器的内存。
分区使Redis的计算能力通过简单地增加计算机得到成倍提升,
Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。

### 6.Redis的内存占用情况怎么样？

给你举个例子： 100万个键值对（键是0到999999值是字符串“helloworld”）在我的32位的Mac笔记本上 用了100MB。
同样的数据放到一个key里只需要16MB， 这是因为键值有一个很大的开销。 
在Memcached上执行也是类似的结果，但是相对Redis的开销要小一点点，因为Redis会记录类型信息引用计数等等。

### 7.Memcached服务特点及工作原理是什么？

1. 完全基于内存缓存的

2. 节点之间相互独立

3. C/S模式架构，C语言编写，总共2000行代码。

4. 异步Ｉ/O 模型，使用libevent作为事件通知机制。

5. 被缓存的数据以key/value键值对形式存在的。

6. 全部数据存放于内存中，无持久性存储的设计，重启服务器，内存里的数据会丢失。

7. 当内存中缓存的数据容量达到启动时设定的内存值时，就自动使用LRU算法删除过期的缓存数据。

8. 可以对存储的数据设置过期时间，这样过期后的数据自动被清除，服务本身不会监控过期，而是在访问的时候查看key的时间戳,判断是否过期。

9. memcache会对设定的内存进行分块，再把块分组，然后再提供服务。

### 8.如何实现集群中的session共享存储？

Session是运行在一台服务器上的，所有的访问都会到达我们的唯一服务器上，
这样我们可以根据客户端传来的sessionID，来获取session，
或在对应Session不存在的情况下（session 生命周期到了/用户第一次登录），创建一个新的Session；
但是，如果我们在集群环境下，假设我们有两台服务器A，B，用户的请求会由Nginx服务器进行转发
用户登录时，Nginx将请求转发至服务器A上，A创建了新的session，并将SessionID返回给客户端，
用户在浏览其他页面时，客户端验证登录状态，Nginx将请求转发至服务器B，
由于B上并没有对应客户端发来sessionId的session，所以会重新创建一个新的session，
并且再将这个新的sessionID返回给客户端，
这样，我们可以想象一下，用户每一次操作都有1/2的概率进行再次的登录，这样不仅对用户体验特别差，
还会让服务器上的session激增，加大服务器的运行压力。

为了解决集群环境下的seesion共享问题，共有4种解决方案：
1. 粘性session    
粘性session是指Ngnix每次都将同一用户的所有请求转发至同一台服务器上，即将用户与服务器绑定。
2. 服务器session复制  
即每次session发生变化时，创建或者修改，就广播给所有集群中的服务器，使所有的服务器上的session相同。
3. session共享    
缓存session，使用redis， memcached。
4. session持久化   
将session存储至数据库中，像操作数据一样才做session。

### 9.memcached与redis的区别？
1. Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
    memcache只支持简单数据类型，需要客户端自己处理复杂对象

2. Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用（PS：持久化在rdb、aof）。

3. 由于Memcache没有持久化机制，因此宕机所有缓存数据失效。
    Redis配置为持久化，宕机重启后，将自动加载宕机时刻的数据到缓存系统中。具有更好的灾备机制。

4. Memcache可以使用Magent在客户端进行一致性hash做分布式。
    Redis支持在服务器端做分布式（PS:Twemproxy/Codis/Redis-cluster多种分布式实现方式）

5. Memcached的简单限制就是键（key）和Value的限制。最大键长为250个字符。
    可以接受的储存数据不能超过1MB（可修改配置文件变大），因为这是典型slab 的最大值，不适合虚拟机使用。
    Redis的Key长度支持到512k。

6. Redis使用的是单线程模型，保证了数据按顺序提交。Memcache需要使用cas保证数据一致性。
    CAS（Check and Set）是一个确保并发一致性的机制，属于“乐观锁”范畴；
    原理很简单：拿版本号，操作，对比版本号，如果一致就操作，不一致就放弃任何操作
    
7. cpu利用。由于Redis只使用单核，而Memcached可以使用多核，
    所以平均每一个核上Redis在存储小数据时比Memcached性能更高。
    而在100k以上的数据中，Memcached性能要高于Redis 。

8. memcache内存管理：使用Slab Allocation。
    原理相当简单，预先分配一系列大小固定的组，然后根据数据大小选择最合适的块存储。避免了内存碎片。
    缺点：不能变长，浪费了一定空间    memcached默认情况下下一个slab的最大值为前一个的1.25倍。
    
    redis内存管理： Redis通过定义一个数组来记录所有的内存分配情况， Redis采用的是包装的malloc/free，
    相较于Memcached的内存 管理方法来说，要简单很多。
    由于malloc首先以链表的方式搜索已管理的内存中可用的空间分配，导致内存碎片比较多